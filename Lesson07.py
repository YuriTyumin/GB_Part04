# 1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод init()),
# который должен принимать данные (список списков) для формирования матрицы.
# Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
# Примеры матриц: см. в методичке.
# Следующий шаг — реализовать перегрузку метода str() для вывода матрицы в привычном виде.
# Далее реализовать перегрузку метода add() для реализации операции сложения двух объектов класса Matrix (двух матриц).
# Результатом сложения должна быть новая матрица.
# Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой строки первой матрицы складываем с первым элементом первой строки второй матрицы и т.д.
# from random import randint
#
# class Matrix:
#     def __init__(self, lst: list):
#         self.lst = lst
#         print(self.lst)
#
#     # Так и не понял как обработать возникающую при выводе ошибку
#     def __str__(self):
#         for i in self.lst:
#             print(str(i))
#
#         # self.c = str(self.lst)
#         # return self.c
#
#         # for i in range(0, len(self.lst)):
#         #     print(self.lst[i])
#
#         # try:
#         #     for i in range(0, len(self.lst)):
#         #         print(self.lst[i])
#         # except TypeError:
#         #     return self.lst[i]
#
#     def __add__(self, other):
#         result = []
#         numbers = []
#         for i in range(len(self.lst)):
#             for j in range(len(self.lst[0])):
#                 summa = other.lst[i][j] + self.lst[i][j]
#                 numbers.append(summa)
#                 if len(numbers) == len(self.lst):
#                     result.append(numbers)
#                     numbers = []
#         return Matrix(result)
#
#
# def matrix(num_string, num_column):
#     list_list = []
#     for n in range(0, num_string):
#         list_element = []
#         for i in range(0, num_column):
#             list_element.insert(i, randint(0, randint(0, 100)))
#         list_list.insert(n, list_element)
#     #print(list_list)
#     return list_list
#
#
# num_string = int(input(f'Введите кол-во строк в матрице: '))
# num_column = int(input(f'Введите кол-во столбцов в матрице: '))
# matrix_1 = matrix(num_string, num_column)
# matrix_2 = matrix(num_string, num_column)
# mtrx_1 = Matrix(matrix_1)
# mtrx_2 = Matrix(matrix_2)
#
# print(mtrx_1 + mtrx_2)
#
# Сложение матриц обычным способом
# list_list = []
# for i in range(0, num_string):
#     list_element = []
#     for j in range(0, num_column):
#         a = matrix_1[i]
#         b = matrix_2[i]
#         c = a[j] + b[j]
#         # print(f'{a[j] + b[j]}')
#         list_element.insert(j, c)
#     list_list.insert(i, list_element)
# print(list_list)
#
# 2. Реализовать проект расчета суммарного расхода ткани на производство одежды.
# Основная сущность (класс) этого проекта — одежда, которая может иметь определенное название.
# К типам одежды в этом проекте относятся пальто и костюм. У этих типов одежды существуют параметры:
# размер (для пальто) и рост (для костюма). Это могут быть обычные числа: V и H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто (V/6.5 + 0.5), для костюма (2*H + 0.3).
# Проверить работу этих методов на реальных данных.
# Реализовать общий подсчет расхода ткани. Проверить на практике полученные на этом уроке знания:
# реализовать абстрактные классы для основных классов проекта, проверить на практике работу декоратора @property.
# from abc import ABC, abstractmethod
#
# class Clothes(ABC):
#
#     @abstractmethod
#     def calculate(self):
#         pass
#
#
# class Coat(Clothes):
#     def calculate(self, v, num_v):
#         print(f'Для изготовления {num_v} пальто размером {v} потребуется {round((v/6.5 + 0.5) * num_v, 1)} ткани')
#
#
# class Suit(Clothes):
#     def calculate(self, h, num_h):
#         print(f'Для изготовления {num_h} костюмов ростом {h} потребуется {round((h * 2 + 0.3) * num_h, 1)} ткани')
#
#
# class Total(Clothes):
#     def calculate(self):
#         print(f'Всего для изготовления {num_v} пальто размером {v} и {num_h} костюмов ростом {h} потребуется {round((((v/6.5 + 0.5) * num_v) + ((h * 2 + 0.3) * num_h)), 1)} ткани')
#
#
# v = int(input(f'Введите размер пальто для расчета: '))
# h = int(input(f'Введите рост костюмов для расчета: '))
# num_v = int(input(f'Введите кол-во пальто для расчета: '))
# num_h = int(input(f'Введите кол-во костюмов для расчета: '))
# coat = Coat()
# suit = Suit()
# total = Total()
# coat.calculate(v, num_v)
# suit.calculate(h, num_h)
# total.calculate()
#
# 3. Реализовать программу работы с органическими клетками, состоящими из ячеек. Необходимо создать класс Клетка.
# В его конструкторе инициализировать параметр, соответствующий количеству ячеек клетки (целое число).
# В классе должны быть реализованы методы перегрузки арифметических операторов:
# сложение (add()), вычитание (sub()), умножение (mul()), деление (truediv()).
# Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение,
# умножение и целочисленное (с округлением до целого) деление клеток, соответственно.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух клеток больше нуля,
# иначе выводить соответствующее сообщение.
# Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как произведение количества ячеек этих двух клеток.
# Деление. Создается общая клетка из двух.
# Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих двух клеток.
# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду.
# Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу.
# Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5.
# Тогда метод make_order() вернет строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5.
# Тогда метод make_order() вернет строку: *****\n*****\n*****.
# Подсказка: подробный список операторов для перегрузки доступен по ссылке.
