# 1. Реализовать класс «Дата», функция-конструктор которого должна принимать дату в виде строки формата «день-месяц-год».
# В рамках класса реализовать два метода.
# Первый, с декоратором @classmethod, должен извлекать число, месяц, год и преобразовывать их тип к типу «Число».
# Второй, с декоратором @staticmethod, должен проводить валидацию числа, месяца и года (например, месяц — от 1 до 12).
# Проверить работу полученной структуры на реальных данных.
# class Date:
#     date: str
#
#     def __init__(self, date):
#         self.date = date
#
#
#     @classmethod
#     def classmethod(cls, date):
#         # print(date.split('-'))
#         for i in date.split('-'):
#             i = int(i)
#             print(f'{i}: {type(i)}')
#
#
#     @staticmethod
#     def staticmethod(date):
#         i = date.split('-')
#         if len(i) == 3:
#             if 0 < int(i[0]) < 32:
#                 print("ДЕНЬ-ОК")
#                 if 0 < int(i[1]) < 13:
#                     print("МЕСЯЦ-ОК")
#                 else:
#                     print(f'Указанный параматр "МЕСЯЦ"-{i[1]} находится вне возможного диапазона значений')
#             else:
#                 print(f'Указанный параматр "ДЕНЬ"-{i[0]} находится вне возможного диапазона значений')
#         else:
#             print("Задан некорректный формат данных")
#
#
# date = str(input(f'Введите строку в формате «день-месяц-год»: '))
# Date.staticmethod(date)
# Date.classmethod(date)
#
# 2. Создайте собственный класс-исключение, обрабатывающий ситуацию деления на нуль.
# Проверьте его работу на данных, вводимых пользователем.
# При вводе пользователем нуля в качестве делителя программа должна корректно обработать эту ситуацию и не завершиться с ошибкой.
# class MyDivisionByZero(Exception):
#     def __init__(self, txt):
#         self.txt = txt
#
#
# num1 = input("Введите делимое: ")
# num2 = input("Введите делитель: ")
#
# try:
#     num1 = int(num1)
#     num2 = int(num2)
#     if num2 == 0:
#         raise MyDivisionByZero("Вы ввели '0' в качестве делителя!")
#     else:
#         result = num1/num2
# except ValueError:
#     print("Вы ввели не число")
# except MyDivisionByZero as err:
#     print(err)
# else:
#     print(f"Все хорошо. Результат деления {num1} на {num2}: {round(result, 1)}")
#
# 3. Создайте собственный класс-исключение, который должен проверять содержимое списка на наличие только чисел.
# Проверить работу исключения на реальном примере. Необходимо запрашивать у пользователя данные и заполнять список только числами.
# Класс-исключение должен контролировать типы данных элементов списка.
# Примечание: длина списка не фиксирована. Элементы запрашиваются бесконечно, пока пользователь сам не остановит работу скрипта,
# введя, например, команду “stop”. При этом скрипт завершается, сформированный список с числами выводится на экран.
# Подсказка: для данного задания примем, что пользователь может вводить только числа и строки.
# При вводе пользователем очередного элемента необходимо реализовать проверку типа элемента и вносить его в список,
# только если введено число.
# Класс-исключение должен не позволить пользователю ввести текст (не число) и отобразить соответствующее сообщение.
# При этом работа скрипта не должна завершаться.
# class MyException(Exception):
#     def __init__(self, txt):
#         self.txt = txt
#
#
# my_str = []
# while True:
#     num = input("Введите число. Для выхода из программы введите 'stop': ")
#     try:
#         if num != 'stop':
#             if num.isdigit():
#                 my_str.append(num)
#             else:
#                 raise MyException("Вы ввели не число!")
#         else:
#             print(my_str)
#             break
#     except MyException as err:
#         print(err)
#
# 4. Начните работу над проектом «Склад оргтехники». Создайте класс, описывающий склад.
# А также класс «Оргтехника», который будет базовым для классов-наследников.
# Эти классы — конкретные типы оргтехники (принтер, сканер, ксерокс).
# В базовом классе определить параметры, общие для приведенных типов.
# В классах-наследниках реализовать параметры, уникальные для каждого типа оргтехники.






























#
#
#
# 5. Продолжить работу над первым заданием.
# Разработать методы, отвечающие за приём оргтехники на склад и передачу в определенное подразделение компании.
# Для хранения данных о наименовании и количестве единиц оргтехники, а также других данных,
# можно использовать любую подходящую структуру, например словарь.
#
#
#
# 6. Продолжить работу над вторым заданием. Реализуйте механизм валидации вводимых пользователем данных.
# Например, для указания количества принтеров, отправленных на склад, нельзя использовать строковый тип данных.
# Подсказка: постарайтесь по возможности реализовать в проекте «Склад оргтехники» максимум возможностей, изученных на уроках по ООП.
#
#
#
# 7. Реализовать проект «Операции с комплексными числами».
# Создайте класс «Комплексное число», реализуйте перегрузку методов сложения и умножения комплексных чисел.
# Проверьте работу проекта, создав экземпляры класса (комплексные числа) и выполнив сложение и умножение созданных экземпляров.
# Проверьте корректность полученного результата.
